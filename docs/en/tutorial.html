<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Tutorial · Relay</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Tutorial · Relay"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/relay/index.html"/><meta property="og:description" content="In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay – from the GraphQL schema on the server, to the React application on the client."/><link rel="shortcut icon" href="/relay/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/relay/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/relay/"><img class="logo" src="/relay/img/relay-white.svg"/><h2 class="headerTitle">Relay</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/relay/docs/en/getting-started.html" target="_self">Docs</a></li><li><a href="/relay/en/help.html" target="_self">Support</a></li><li><a href="https://github.com/facebook/relay" target="_self">GitHub</a></li><li><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Quick Start</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Quick Start</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/getting-started.html">Getting Started</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/relay/docs/en/tutorial.html">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/thinking-in-graphql.html">Thinking in GraphQL</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/thinking-in-relay.html">Thinking In Relay</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/videos.html">Videos</a></li></ul></div><div class="navGroup navGroupActive"><h3>Relay Modern</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-modern.html">Introduction to Relay Modern</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/new-in-relay-modern.html">New in Relay Modern</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-environment.html">The Relay &quot;Environment&quot;</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/network-layer.html">The Relay Network Layer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/query-renderer.html">QueryRenderer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/fragment-container.html">FragmentContainer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/refetch-container.html">RefetchContainer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/pagination-container.html">PaginationContainer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/routing.html">Routing</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/mutations.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/subscriptions.html">Subscriptions</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-directives.html">Directives</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/babel-plugin-relay.html">babel-plugin-relay</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-compiler.html">Relay Compiler</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-debugging.html">Debugging</a></li></ul></div><div class="navGroup navGroupActive"><h3>Relay Compat</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/relay-compat.html">Compatibility Mode</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/conversion-playbook.html">Conversion Playbook</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/conversion-scripts.html">Conversion Scripts</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/upgrading-setvariables.html">Upgrading setVariables</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/compatibility-cheatsheet.html">Compatibility Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-cheatsheet.html">API Cheatsheet</a></li></ul></div><div class="navGroup navGroupActive"><h3>Relay Classic Guides</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-containers.html">Containers</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-routes.html">Routes</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-root-container.html">Root Container</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-ready-state.html">Ready State</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-mutations.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-network-layer.html">Network Layer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/guides-babel-plugin.html">Babel Relay Plugin</a></li></ul></div><div class="navGroup navGroupActive"><h3>GraphQL</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/graphql-relay-specification.html">GraphQL Relay Specification</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/graphql-object-identification.html">Object Identification</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/graphql-connections.html">Connection</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/graphql-mutations.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/graphql-further-reading.html">Further Reading</a></li></ul></div><div class="navGroup navGroupActive"><h3>Relay Classic API</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay.html">Relay</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-container.html">RelayContainer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-route.html">Relay.Route</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-renderer.html">Relay.Renderer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-root-container.html">Relay.RootContainer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-ql.html">Relay.QL</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-mutation.html">Relay.Mutation</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-graphql-mutation.html">Relay.GraphQLMutation</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-proptypes.html">Relay.PropTypes</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/api-reference-relay-store.html">Relay.Store</a></li></ul></div><div class="navGroup navGroupActive"><h3>Relay Classic Interfaces</h3><ul><li class="navListItem"><a class="navItem" href="/relay/docs/en/interfaces-relay-mutation-request.html">RelayMutationRequest</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/interfaces-relay-network-layer.html">RelayNetworkLayer</a></li><li class="navListItem"><a class="navItem" href="/relay/docs/en/interfaces-relay-query-request.html">RelayQueryRequest</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/relay/edit/master/docs/QuickStart-Tutorial.md" target="_blank">Edit</a><h1>Tutorial</h1></header><article><div><span><p>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay – from the GraphQL schema on the server, to the React application on the client.</p>
<h2><a class="anchor" aria-hidden="true" name="warm-up"></a><a href="#warm-up" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Warm up</h2>
<p>Let's start a project using the <a href="https://github.com/relayjs/relay-starter-kit">Relay Starter Kit</a> as a base.</p>
<pre><code class="hljs">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/relayjs/relay-starter-kit.git relay-treasurehunt
cd relay-treasurehunt
yarn install
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="a-simple-database"></a><a href="#a-simple-database" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A simple database</h2>
<p>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</p>
<pre><code class="hljs"><span class="hljs-comment">/**
 * ./data/database.js
 */</span>

<span class="hljs-comment">// Model types</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>{}
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HidingSpot</span> </span>{}

<span class="hljs-comment">// Mock data</span>
<span class="hljs-keyword">const</span> game = <span class="hljs-keyword">new</span> Game();
game.id = <span class="hljs-string">'1'</span>;

<span class="hljs-keyword">const</span> hidingSpots = [];
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> hidingSpot;
  <span class="hljs-keyword">const</span> indexOfSpotWithTreasure = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">9</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    hidingSpot = <span class="hljs-keyword">new</span> HidingSpot();
    hidingSpot.id = <span class="hljs-string">`<span class="hljs-subst">${i}</span>`</span>;
    hidingSpot.hasTreasure = (i === indexOfSpotWithTreasure);
    hidingSpot.hasBeenChecked = <span class="hljs-literal">false</span>;
    hidingSpots.push(hidingSpot);
  }
})();

<span class="hljs-keyword">let</span> turnsRemaining = <span class="hljs-number">3</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkHidingSpotForTreasure</span>(<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">if</span> (hidingSpots.some(<span class="hljs-function"><span class="hljs-params">hs</span> =&gt;</span> hs.hasTreasure &amp;&amp; hs.hasBeenChecked)) {
    <span class="hljs-keyword">return</span>;
  }
  turnsRemaining--;
  <span class="hljs-keyword">const</span> hidingSpot = getHidingSpot(id);
  hidingSpot.hasBeenChecked = <span class="hljs-literal">true</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHidingSpot</span>(<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">return</span> hidingSpots.find(<span class="hljs-function"><span class="hljs-params">hs</span> =&gt;</span> hs.id === id);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGame</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> game; }
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHidingSpots</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> hidingSpots; }
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTurnsRemaining</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> turnsRemaining; }
</code></pre>
<p>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</p>
<h2><a class="anchor" aria-hidden="true" name="authoring-a-schema"></a><a href="#authoring-a-schema" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Authoring a schema</h2>
<p>A GraphQL schema describes your data model, and provides a GraphQL server with
an associated set of resolve methods that know how to fetch data. We will use
<a href="https://github.com/graphql/graphql-js">graphql-js</a> and
<a href="https://github.com/graphql/graphql-relay-js">graphql-relay-js</a> to build our
schema.</p>
<p>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</p>
<pre><code class="hljs"><span class="hljs-comment">/**
 * ./data/schema.js
 */</span>

<span class="hljs-comment">/* ... */</span>

import {
<span class="hljs-built_in">  Game,</span>
<span class="hljs-built_in">  HidingSpot,</span>
<span class="hljs-built_in">  checkHidingSpotForTreasure,</span>
<span class="hljs-built_in">  getGame,</span>
<span class="hljs-built_in">  getHidingSpot,</span>
<span class="hljs-built_in">  getHidingSpots,</span>
<span class="hljs-built_in">  getTurnsRemaining,</span>
} from './database'<span class="hljs-comment">;</span>
</code></pre>
<p>At this point, you can delete everything up until <code>queryType</code> in <code>./data/schema.js</code>.</p>
<p>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> {nodeInterface, nodeField} = nodeDefinitions(
  <span class="hljs-function">(<span class="hljs-params">globalId</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> {<span class="hljs-keyword">type</span>, id} = fromGlobalId(globalId);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'Game'</span>) {
      <span class="hljs-keyword">return</span> getGame(id);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'HidingSpot'</span>) {
      <span class="hljs-keyword">return</span> getHidingSpot(id);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  },
  <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Game) {
      <span class="hljs-keyword">return</span> gameType;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> HidingSpot) {
      <span class="hljs-keyword">return</span> hidingSpotType;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }
);
</code></pre>
<p>Next, let's define our game and hiding spot types, and the fields that are available on each.</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> gameType = <span class="hljs-keyword">new</span> GraphQLObjectType({
  name: <span class="hljs-string">'Game'</span>,
  description: <span class="hljs-string">'A treasure search game'</span>,
  fields: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    id: globalIdField(<span class="hljs-string">'Game'</span>),
    hidingSpots: {
      <span class="hljs-keyword">type</span>: hidingSpotConnection,
      description: <span class="hljs-string">'Places where treasure might be hidden'</span>,
      args: connectionArgs,
      resolve: <span class="hljs-function">(<span class="hljs-params">game, args</span>) =&gt;</span> connectionFromArray(getHidingSpots(), args),
    },
    turnsRemaining: {
      <span class="hljs-keyword">type</span>: GraphQLInt,
      description: <span class="hljs-string">'The number of turns a player has left to find the treasure'</span>,
      resolve: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> getTurnsRemaining(),
    },
  }),
  interfaces: [nodeInterface],
});

<span class="hljs-keyword">const</span> hidingSpotType = <span class="hljs-keyword">new</span> GraphQLObjectType({
  name: <span class="hljs-string">'HidingSpot'</span>,
  description: <span class="hljs-string">'A place where you might find treasure'</span>,
  fields: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    id: globalIdField(<span class="hljs-string">'HidingSpot'</span>),
    hasBeenChecked: {
      <span class="hljs-keyword">type</span>: GraphQLBoolean,
      description: <span class="hljs-string">'True if this spot has already been checked for treasure'</span>,
      resolve: <span class="hljs-function">(<span class="hljs-params">hidingSpot</span>) =&gt;</span> hidingSpot.hasBeenChecked,
    },
    hasTreasure: {
      <span class="hljs-keyword">type</span>: GraphQLBoolean,
      description: <span class="hljs-string">'True if this hiding spot holds treasure'</span>,
      resolve: <span class="hljs-function">(<span class="hljs-params">hidingSpot</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (hidingSpot.hasBeenChecked) {
          <span class="hljs-keyword">return</span> hidingSpot.hasTreasure;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Shh... it's a secret!</span>
        }
      },
    },
  }),
  interfaces: [nodeInterface],
});
</code></pre>
<p>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</p>
<pre><code class="hljs">const {<span class="hljs-string">connectionType:</span> hidingSpotConnection} =
  connectionDefinitions({<span class="hljs-string">name:</span> <span class="hljs-string">'HidingSpot'</span>, <span class="hljs-string">nodeType:</span> hidingSpotType});
</code></pre>
<p>Now let's associate these types with the root query type.</p>
<pre><code class="hljs">const queryType = <span class="hljs-keyword">new</span> GraphQLObjectType({
  name: <span class="hljs-string">'Query'</span>,
  fields: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    node: nodeField,
    game: {
      type: gameType,
      resolve: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> getGame(),
    },
  }),
});
</code></pre>
<p>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</p>
<pre><code class="hljs">const CheckHidingSpotForTreasureMutation = mutationWithClientMutationId({
  name: 'CheckHidingSpotForTreasure',
  inputFields: {
    id: { type: new GraphQLNonNull(<span class="hljs-name">GraphQLID</span>) },
  },
  outputFields: {
    hidingSpot: {
      type: hidingSpotType,
      resolve: ({localHidingSpotId}) =&gt; getHidingSpot(<span class="hljs-name">localHidingSpotId</span>),
    },
    game: {
      type: gameType,
      resolve: () =&gt; getGame(),
    },
  },
  mutateAndGetPayload: ({id}) =&gt; {
    const localHidingSpotId = fromGlobalId(<span class="hljs-name">id</span>).id<span class="hljs-comment">;</span>
    checkHidingSpotForTreasure(<span class="hljs-name">localHidingSpotId</span>)<span class="hljs-comment">;</span>
    return {localHidingSpotId}<span class="hljs-comment">;</span>
  },
})<span class="hljs-comment">;</span>
</code></pre>
<p>Let's associate the mutation we just created with the root mutation type:</p>
<pre><code class="hljs">const mutationType = <span class="hljs-keyword">new</span> GraphQLObjectType({
  name: <span class="hljs-string">'Mutation'</span>,
  fields: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    checkHidingSpotForTreasure: CheckHidingSpotForTreasureMutation,
  }),
});
</code></pre>
<p>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</p>
<pre><code class="hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Schema = <span class="hljs-keyword">new</span> GraphQLSchema({
  query: queryType,
  mutation: mutationType
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="processing-the-schema"></a><a href="#processing-the-schema" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Processing the schema</h2>
<p>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</p>
<pre><code class="hljs">yarn <span class="hljs-keyword">run</span><span class="bash"> update-schema
</span>yarn start
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="writing-the-game"></a><a href="#writing-the-game" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing the game</h2>
<p>Let's tweak the file <code>./js/routes/AppHomeRoute.js</code> to anchor our game to the <code>game</code> root field of the schema:</p>
<pre><code class="hljs">export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Route</span> </span>{
  static queries = {
    game: () =&gt; <span class="hljs-type">Relay</span>.<span class="hljs-type">QL</span>`query { game }`,
  };
  static routeName = <span class="hljs-symbol">'AppHomeRout</span>e';
}
</code></pre>
<p>Next, let's create a file in <code>./js/mutations/CheckHidingSpotForTreasureMutation.js</code> and create subclass of <code>Relay.Mutation</code> called <code>CheckHidingSpotForTreasureMutation</code> to hold our mutation implementation:</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> Relay <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckHidingSpotForTreasureMutation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Relay</span>.<span class="hljs-title">Mutation</span> {</span>
  static fragments = {
    game: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Relay.QL`<span class="javascript">
      fragment on Game {
        id,
        turnsRemaining,
      }
    </span>`,
    hidingSpot: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Relay.QL`<span class="javascript">
      fragment on HidingSpot {
        id,
      }
    </span>`,
  };
  getMutation() {
    <span class="hljs-keyword">return</span> Relay.QL`<span class="javascript">mutation{checkHidingSpotForTreasure}</span>`;
  }
  getCollisionKey() {
    <span class="hljs-keyword">return</span> `<span class="javascript">check_${<span class="hljs-keyword">this</span>.props.game.id}</span>`;
  }
  getFatQuery() {
    <span class="hljs-keyword">return</span> Relay.QL`<span class="javascript">
      fragment on CheckHidingSpotForTreasurePayload @relay(pattern: <span class="hljs-literal">true</span>) {
        hidingSpot {
          hasBeenChecked,
          hasTreasure,
        },
        game {
          turnsRemaining,
        },
      }
    </span>`;
  }
  getConfigs() {
    <span class="hljs-keyword">return</span> [{
      type: <span class="hljs-string">'FIELDS_CHANGE'</span>,
      fieldIDs: {
        hidingSpot: <span class="hljs-keyword">this</span>.props.hidingSpot.id,
        game: <span class="hljs-keyword">this</span>.props.game.id,
      },
    }];
  }
  getVariables() {
    <span class="hljs-keyword">return</span> {
      id: <span class="hljs-keyword">this</span>.props.hidingSpot.id,
    };
  }
  getOptimisticResponse() {
    <span class="hljs-keyword">return</span> {
      game: {
        turnsRemaining: <span class="hljs-keyword">this</span>.props.game.turnsRemaining - <span class="hljs-number">1</span>,
      },
      hidingSpot: {
        id: <span class="hljs-keyword">this</span>.props.hidingSpot.id,
        hasBeenChecked: <span class="hljs-literal">true</span>,
      },
    };
  }
}
</code></pre>
<p>Finally, let's tie it all together in <code>./js/components/App.js</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> CheckHidingSpotForTreasureMutation from <span class="hljs-string">'../mutations/CheckHidingSpotForTreasureMutation'</span>;
<span class="hljs-keyword">import</span> React from <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> Relay from <span class="hljs-string">'react-relay'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  _getHidingSpotStyle(hidingSpot) {
    let color;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.relay.hasOptimisticUpdate(hidingSpot)) {
      color = <span class="hljs-string">'lightGrey'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hidingSpot.hasBeenChecked) {
      <span class="hljs-keyword">if</span> (hidingSpot.hasTreasure) {
        color = <span class="hljs-string">'blue'</span>;
      } <span class="hljs-keyword">else</span> {
        color = <span class="hljs-string">'red'</span>;
      }
    } <span class="hljs-keyword">else</span> {
      color = <span class="hljs-string">'black'</span>;
    }
    <span class="hljs-keyword">return</span> {
      backgroundColor: color,
      cursor: <span class="hljs-keyword">this</span>._isGameOver() ? <span class="hljs-literal">null</span> : <span class="hljs-string">'pointer'</span>,
      display: <span class="hljs-string">'inline-block'</span>,
      height: <span class="hljs-number">100</span>,
      marginRight: <span class="hljs-number">10</span>,
      width: <span class="hljs-number">100</span>,
    };
  }
  _handleHidingSpotClick(hidingSpot) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isGameOver()) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">this</span>.props.relay.commitUpdate(
      new CheckHidingSpotForTreasureMutation({
        game: <span class="hljs-keyword">this</span>.props.game,
        hidingSpot,
      })
    );
  }
  _hasFoundTreasure() {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-keyword">this</span>.props.game.hidingSpots.edges.some(edge =&gt; edge.node.hasTreasure)
    );
  }
  _isGameOver() {
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.props.game.turnsRemaining || <span class="hljs-keyword">this</span>._hasFoundTreasure();
  }
  renderGameBoard() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.game.hidingSpots.edges.map(edge =&gt; {
      <span class="hljs-keyword">return</span> (
        &lt;div
          key={edge.node.id}
          onClick={<span class="hljs-keyword">this</span>._handleHidingSpotClick.bind(<span class="hljs-keyword">this</span>, edge.node)}
          style={<span class="hljs-keyword">this</span>._getHidingSpotStyle(edge.node)}
        /&gt;
      );
    });
  }
  render() {
    let headerText;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.relay.getPendingTransactions(<span class="hljs-keyword">this</span>.props.game)) {
      headerText = <span class="hljs-string">'\u2026'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._hasFoundTreasure()) {
      headerText = <span class="hljs-string">'You win!'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isGameOver()) {
      headerText = <span class="hljs-string">'Game over!'</span>;
    } <span class="hljs-keyword">else</span> {
      headerText = <span class="hljs-string">'Find the treasure!'</span>;
    }
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;h1&gt;{headerText}&lt;/h1&gt;
        {<span class="hljs-keyword">this</span>.renderGameBoard()}
        &lt;p&gt;Turns remaining: {<span class="hljs-keyword">this</span>.props.game.turnsRemaining}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export <span class="hljs-keyword">default</span> Relay.createContainer(App, {
  fragments: {
    game: () =&gt; Relay.QL`
      fragment on Game {
        turnsRemaining,
        hidingSpots(first: <span class="hljs-number">9</span>) {
          edges {
            node {
              hasBeenChecked,
              hasTreasure,
              id,
              ${CheckHidingSpotForTreasureMutation.getFragment(<span class="hljs-string">'hidingSpot'</span>)},
            }
          }
        },
        ${CheckHidingSpotForTreasureMutation.getFragment(<span class="hljs-string">'game'</span>)},
      }
    `,
  },
});
</code></pre>
<p>A working copy of the treasure hunt can be found in the <a href="https://github.com/relayjs/relay-examples">relay-examples</a> repository.</p>
<p>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="getting-started.html">← Getting Started</a><a class="docs-next button" href="thinking-in-graphql.html">Thinking in GraphQL →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/relay/" class="nav-home"><img src="/relay/img/relay.svg" alt="Relay" width="66" height="58"/></a><div><h5>Docs</h5><a href="/relay/docs/en/getting-started.html">Getting Started</a></div><div><h5>Community</h5><a href="/relay/en/users.html">User Showcase</a></div><div><h5>More</h5><a href="https://github.com/facebook/relay">GitHub</a><a class="github-button" href="https://github.com/facebook/relay" data-icon="octicon-star" data-count-href="/facebook/relay/stargazers" data-count-api="/repos/facebook/relay#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/relay/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '3d7d5825d50ea36bca0e6ad06c926f06',
                indexName: 'relay',
                inputSelector: '#search_input_react'
              });
            </script></body></html>